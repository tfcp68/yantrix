import { beforeEach, describe, expect, it, vi, vitest } from 'vitest';
import { AbstractBaseClass } from '../src/mixins/BaseClass.js';
import BasicStateDictionary from '../src/StateDictionary.js';

class StateDictionaryTest extends BasicStateDictionary {
	#defaultStateValidator: typeof this.validateState;

	constructor() {
		super();
		this.#defaultStateValidator = this.validateState;
	}

	getDefaultStateValidator() {
		return this.#defaultStateValidator;
	}
}

let sampleInstance: StateDictionaryTest;

/* const testNamespace = 'test';
const testNamespaceCross = 'cross';
const testNamespaceExtra = 'extra'; */

const testState = 'test_state_';

describe('stateDictionary', () => {
	beforeEach(() => {
		vitest.restoreAllMocks();
		vitest.clearAllTimers();
		sampleInstance = new StateDictionaryTest();
	});

	describe('constructor', () => {
		it('returns an instance of StateDictionaryTest', () => {
			expect(sampleInstance).toBeInstanceOf(BasicStateDictionary);
		});
		it('returns an instance of AbstractBaseClass', () => {
			expect(sampleInstance).toBeInstanceOf(AbstractBaseClass);
		});
		it('has an autogenerated alphanumeric Correlation ID', () => {
			expect(sampleInstance)
				.property('correlationId')
				.to
				.match(/^[A-Z0-9]+$/);
		});
		it('is empty by default', () => {
			expect(sampleInstance.getDictionary()).toEqual({});
		});
	});

	describe('/getStateKeys', () => {
		it('returns empty array for empty input', () => {
			expect(sampleInstance.getStateKeys({ states: [] })).toEqual([]);
		});
		it('returns state keys with matching namespace', () => {
			const stateKeys = ['state1', 'state2'];
			const namespace = 'test_namespace';

			const ids = sampleInstance.addStates({ namespace, keys: stateKeys });
			const result = sampleInstance.getStateKeys({ states: ids, namespace });

			expect(result).toHaveLength(stateKeys.length);
			expect(result[0]).toContain(stateKeys[0]);
			expect(result[1]).toContain(stateKeys[1]);
		});
	});

	describe('/clearStates', () => {
		it('returns self', () => {
			expect(sampleInstance.clearStates()).toBe(sampleInstance);
		});
		it('clears all states and leaves dictionary empty', () => {
			sampleInstance.addStates({ keys: ['state1', 'state2', 'state3'] });
			sampleInstance.clearStates();
			expect(sampleInstance.getDictionary()).toEqual({});
		});
	});

	describe('/removeStates', () => {
		it('returns self', () => {
			expect(sampleInstance.removeStates({ states: [] })).toBe(sampleInstance);
		});

		it('removes single state by key', () => {
			sampleInstance.addStates({ keys: [testState] });
			expect(sampleInstance.removeStates({ keys: [testState] }).getDictionary()).not.toHaveProperty(testState);
		});

		it('removes multiple states by key', () => {
			const stateKeys = ['state1', 'state2', 'state3'];
			const extraKeys = ['stateExtra'];
			sampleInstance.addStates({ keys: [...stateKeys, ...extraKeys] });
			const states = sampleInstance.removeStates({ keys: stateKeys }).getDictionary();
			expect(Object.keys(states)).toEqual(extraKeys);
		});

		it('does not remove non-existing states', () => {
			const stateKeys = ['state1', 'state2', 'state3'];
			expect(sampleInstance
				.removeStates({ keys: stateKeys })
				.getDictionary(),
			).toEqual({});
		});
		it('removes associated contextTransformers', () => {
			const stateKey = 'newState';
			const stateId = sampleInstance.addStates({ keys: [stateKey] })[0]!;
			const transformerName = sampleInstance.addContextTransformer(stateId, () => ({ state: 0, context: null }), 'test');
			expect(sampleInstance.getContextTransformers('test')[stateId]).toHaveProperty(transformerName);
			sampleInstance.removeStates({ keys: [stateKey] }, true);
			expect(sampleInstance.getContextTransformers('test')[stateId]).not.toHaveProperty(transformerName);
		});
	});

	describe('/getStateValues', () => {
		it('returns empty array for empty input', () => {
			expect(sampleInstance.getStateValues({ keys: [] })).toEqual([]);
		});

		it('returns single state by key', () => {
			const stateKey = 'newState';
			sampleInstance.addStates({ keys: [stateKey] });
			expect(sampleInstance.getStateValues({ keys: [stateKey] })).toHaveLength(1); ;
		});

		it('returns multiple states by key', () => {
			const stateKeys = ['state1', 'state2', 'state3'];
			sampleInstance.addStates({ keys: stateKeys });
			expect(sampleInstance.getStateValues({ keys: stateKeys })).toHaveLength(3);
		});

		it('does not return non-existing states', () => {
			const stateKeys = ['state1', 'state2', 'state3'];
			expect(sampleInstance.getStateValues({ keys: stateKeys })).toEqual([null, null, null]);
		});
	});

	describe('/addStates', () => {
		it('returns array of states', () => {
			const result = sampleInstance.addStates({ keys: ['test'] });
			expect(result).toBeInstanceOf(Array);
		});

		it('adds a single state', () => {
			const stateKey = 'newState';
			const result = sampleInstance.addStates({ keys: [stateKey] });
			expect(result).toHaveLength(1);
			expect(result[0]).toBeTypeOf('number');
			expect(result[0]).toBeGreaterThan(0);
		});

		it('adds multiple states', () => {
			const stateKeys = ['state1', 'state2', 'state3'];
			const result = sampleInstance.addStates({ keys: stateKeys });
			expect(result).toHaveLength(stateKeys.length);
			expect(result[0]).toBeGreaterThan(0);
			expect(result[1]).toBeGreaterThan(0);
			expect(result[2]).toBeGreaterThan(0);
		});

		it('throws on duplicate states', () => {
			const stateKey = 'duplicateState';
			sampleInstance.addStates({ keys: [stateKey] });
			expect (() => sampleInstance.addStates({ keys: [stateKey] })).toThrow();
		});

		it('handles undefined keys gracefully', () => {
			const result = sampleInstance.addStates({ states: undefined } as any);
			expect(result).toEqual([]);
		});

		it('adds states with namespace', () => {
			const stateKey = 'namespacedState';
			const namespace = 'testNamespace';
			const result = sampleInstance.addStates({ keys: [stateKey], namespace });
			expect(result).toHaveLength(1);
			expect(result[0]).toBeGreaterThan(0);
			expect(Object.keys(sampleInstance.getDictionary(namespace))).toHaveLength(1);
			expect(Object.values(sampleInstance.getDictionary(namespace))[0]).toBe(result[0]);
		});
	});

	describe('/addContextTransformer', () => {
		const mockTransformer = vi.fn(ctx => ctx);
		it('adds transformer', () => {
			const stateId = sampleInstance.addStates({ keys: [testState] })[0]!;
			const id = sampleInstance.addContextTransformer(stateId, mockTransformer);
			expect(id).toBeTypeOf('string');
			expect(sampleInstance.getContextTransformers()).toHaveProperty(String(stateId));
			expect(Object.keys(sampleInstance.getContextTransformers()[String(stateId)]!)).toHaveLength(1);
			expect(sampleInstance.getContextTransformers()[String(stateId)]).toEqual(
				{ [id]: expect.objectContaining({
					namespace: undefined,
					transformer: mockTransformer,
				}) },
			);
		});

		it('throws on duplicate transformers', () => {
			const stateId = sampleInstance.addStates({ keys: [testState] })[0]!;
			sampleInstance.addContextTransformer(stateId, mockTransformer);
			expect(() => sampleInstance.addContextTransformer(stateId, mockTransformer)).toThrow();
		});

		it('adds transformer with namespace', () => {
			const stateId = sampleInstance.addStates({ keys: [testState], namespace: 'test' })[0]!;
			const id = sampleInstance.addContextTransformer(stateId, mockTransformer, 'test');
			expect(id).toBeTypeOf('string');
			expect(sampleInstance.getContextTransformers('test')[String(stateId)]).toEqual(
				{ [id]: expect.objectContaining({
					namespace: 'test',
					transformer: mockTransformer,
				}) },
			);
		});
	});

	describe('/removeContextTransformer', () => {
		const mockTransformer = vi.fn(ctx => ctx);
		it('removes transformer', () => {
			const stateId = sampleInstance.addStates({ keys: [testState] })[0]!;
			const extraTransfromer = vi.fn(ctx => ctx);
			const testId = sampleInstance.addContextTransformer(stateId, mockTransformer);
			const extraId = sampleInstance.addContextTransformer(stateId, extraTransfromer);
			sampleInstance.removeContextTransformer(stateId, mockTransformer);
			expect(sampleInstance.getContextTransformers()[String(stateId)]).not.toHaveProperty(testId);
			expect(sampleInstance.getContextTransformers()[String(stateId)]).toHaveProperty(extraId);
		});

		it('gracefully handles non-existing transformer', () => {
			const stateId = sampleInstance.addStates({ keys: [testState] })[0]!;
			sampleInstance.addContextTransformer(stateId, vi.fn(ctx => ctx));
			const transformers = sampleInstance.getContextTransformers();
			sampleInstance.removeContextTransformer(stateId, mockTransformer);
			expect(transformers).toEqual(sampleInstance.getContextTransformers());
		});

		it('removes transformer with namespace', () => {
			const stateId = sampleInstance.addStates({ keys: [testState], namespace: 'test' })[0]!;
			const id = sampleInstance.addContextTransformer(stateId, mockTransformer, 'test');
			expect(sampleInstance.getContextTransformers('test')[String(stateId)]).toHaveProperty(id);
			sampleInstance.removeContextTransformer(stateId, mockTransformer, 'test');
			expect(sampleInstance.getContextTransformers('test')[String(stateId)]).not.toHaveProperty(id);
		});
	});

	describe('/removeContextTransformerById', () => {
		const mockTransformer = vi.fn(ctx => ctx);

		it('removes transformer by id', () => {
			const stateId = sampleInstance.addStates({ keys: [testState] })[0]!;
			const id = sampleInstance.addContextTransformer(stateId, mockTransformer);
			expect(sampleInstance.getContextTransformers()[String(stateId)]).toHaveProperty(id);
			sampleInstance.removeContextTransformerById(id);
			expect(sampleInstance.getContextTransformers()[String(stateId)]).not.toHaveProperty(id);
		});

		it('gracefully handles non-existing id', () => {
			const stateId = sampleInstance.addStates({ keys: [testState] })[0]!;
			sampleInstance.addContextTransformer(stateId, mockTransformer);
			const transformersBefore = sampleInstance.getContextTransformers();
			sampleInstance.removeContextTransformerById('nonExistingId');
			expect(transformersBefore).toEqual(sampleInstance.getContextTransformers());
		});

		it('removes transformer by id with namespace', () => {
			const stateId = sampleInstance.addStates({ keys: [testState], namespace: 'test' })[0]!;
			const id = sampleInstance.addContextTransformer(stateId, mockTransformer, 'test');
			expect(sampleInstance.getContextTransformers('test')[String(stateId)]).toHaveProperty(id);
			sampleInstance.removeContextTransformerById(id);
			expect(sampleInstance.getContextTransformers('test')[String(stateId)]).not.toHaveProperty(id);
		});
	});

	describe('/runContextTransformers', () => {
		const mockTransformer = vi.fn(ctx => ctx);
		it('runs transformer when passed corresponding states', () => {
			const stateId = sampleInstance.addStates({ keys: [testState] })[0]!;
			const id = sampleInstance.addContextTransformer(stateId, mockTransformer);
			sampleInstance.runContextTransformers(id, { state: stateId, context: null });
			expect(mockTransformer).toHaveBeenCalledWith({ state: stateId, context: null });
		});
		it('does not run transformer when passed different state', () => {
			const stateId = sampleInstance.addStates({ keys: [testState] })[0]!;
			const id = sampleInstance.addContextTransformer(stateId, mockTransformer);
			sampleInstance.runContextTransformers(id, { state: stateId + 1, context: null });
			expect(mockTransformer).not.toHaveBeenCalled();
		});
	});
});
