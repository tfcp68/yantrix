import { randomInteger } from '@yantrix/utils';
import { beforeEach, describe, expect, it, vitest } from 'vitest';
import { createEventBus, TEventBusHandler } from '../src';
import { AbstractBaseClass } from '../src/mixins/BaseClass.js';
import { TTestEvent, TTestEventMeta } from './fixtures/index.js';

class EventBusTest extends createEventBus<
	TTestEvent,
	TTestEventMeta<TTestEvent>
>()(AbstractBaseClass) {

}

const createEventWithCallback:
(
	e?: number,
	fn?: TEventBusHandler<number, TTestEventMeta<number>>
) => [
	TTestEvent,
	TEventBusHandler<number, TTestEventMeta<number>>,
] = (event?: number, fn?: TEventBusHandler<number, TTestEventMeta<number>>) => {
	let eventToReturn = randomInteger(1, 10000);
	let callback: TEventBusHandler<number, TTestEventMeta<number>> = ({ event, meta }) => {
		return {
			event,
			meta,
			task_id: 'test_event',
			result: new Promise((resolve, reject) => {
				try {
					resolve([]);
				} catch {
					reject(new Error('Error getting event stack'));
				}
			}),
		};
	};
	if (event) {
		eventToReturn = event;
	}
	if (fn) {
		callback = fn;
	}
	return [eventToReturn, callback];
};

describe('eventBus', () => {
	let sampleInstance: EventBusTest = new EventBusTest();
	beforeEach(() => {
		vitest.restoreAllMocks();
		vitest.clearAllTimers();
		sampleInstance = new EventBusTest();
	});
	describe('constructor', () => {
		it('returns an instance of EventBusTest', () => {
			expect(sampleInstance).toBeInstanceOf(EventBusTest);
		});
		it('returns an instance of AbstractBaseClass', () => {
			expect(sampleInstance).toBeInstanceOf(AbstractBaseClass);
		});
		it('has an autogenerated alphanumeric Correlation ID', () => {
			expect(sampleInstance)
				.property('correlationId')
				.to
				.match(/^[A-Z0-9]+$/);
		});
		it('is empty by default', () => {
			expect(sampleInstance.getEventStack()).toEqual([]);
		});
	});
	describe('event stack', () => {
		it('events are added to event stack', () => {
			const [event, callback] = createEventWithCallback();

			sampleInstance.subscribe(event, callback);

			sampleInstance.pause();

			sampleInstance.dispatch({
				event,
				meta: null,
			});

			expect(sampleInstance.getEventStack().length).toBe(1);
		});
		it('event stack can be cleared', () => {
			const [event, callback] = createEventWithCallback();

			sampleInstance.subscribe(event, callback);

			sampleInstance.pause();

			sampleInstance.dispatch({
				event,
				meta: null,
			});

			expect(sampleInstance.getEventStack().length).toBe(1);

			sampleInstance.clearEventStack();

			expect(sampleInstance.getEventStack().length).toBe(0);
		});
	});
	describe('event processing', () => {
		it('can process events synchronously', () => {
			let processedEventId = 0;
			const [event, callback] = createEventWithCallback(123456, ({ event, meta }) => {
				processedEventId = 123456;

				return {
					event,
					meta,
					task_id: 'test_event',
					result: new Promise((resolve, reject) => {
						try {
							resolve([]);
						} catch {
							reject(new Error('Error getting event stack'));
						}
					}),
				};
			});

			sampleInstance.subscribe(event, callback);
			sampleInstance.dispatch({
				event,
				meta: null,
			});

			expect(processedEventId).toBe(123456);
		});
		it('does not process events if paused', () => {
			const [event, callback] = createEventWithCallback();

			sampleInstance.subscribe(event, callback);

			sampleInstance.pause();

			sampleInstance.dispatch({
				event,
				meta: null,
			});

			expect(sampleInstance.getEventStack().length).toBe(1);
		});
		it('can process events after resume', () => {
			const [event, callback] = createEventWithCallback();

			sampleInstance.subscribe(event, callback);

			sampleInstance.pause();

			sampleInstance.dispatch({
				event,
				meta: null,
			});

			expect(sampleInstance.getEventStack().length).toBe(1);

			sampleInstance.resume();

			expect(sampleInstance.getEventStack().length).toBe(0);
		});
	});
});
