/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const YantrixLanguageTerminals = {
    WS: /\s+/,
    FUNCTION_CALL: /[A-Za-z]{1,}[A-Za-z0-9\.]*([(])/,
    ID: /[a-zA-Z]\w{0,254}/,
    STRING: /"([^"\\]|\\.)*"|'([^'\\]|\\.)*'/,
    DECIMAL: /-?(\d*\.)?\d+/,
    INT: /-?\d+/,
};

export type YantrixLanguageTerminalNames = keyof typeof YantrixLanguageTerminals;

export type YantrixLanguageKeywordNames =
    | "#"
    | "$"
    | "%%"
    | "("
    | ")"
    | "+ByPass"
    | "+Init"
    | ","
    | "<="
    | "="
    | "=>"
    | "?"
    | "[]"
    | "define/"
    | "emit/"
    | "inject/"
    | "subscribe/"
    | "{"
    | "}";

export type YantrixLanguageTokenNames = YantrixLanguageTerminalNames | YantrixLanguageKeywordNames;

export type DefineFunction = ArgumentReference | Constant | FunctionCall | Immutable;

export const DefineFunction = 'DefineFunction';

export function isDefineFunction(item: unknown): item is DefineFunction {
    return reflection.isInstance(item, DefineFunction);
}

export type KeyItem = DataObject | FunctionCall | Immutable;

export const KeyItem = 'KeyItem';

export function isKeyItem(item: unknown): item is KeyItem {
    return reflection.isInstance(item, KeyItem);
}

export type Statement = ByPassStatement | ContextStatement | DefineStatement | EmitStatement | ExpressionStatement | InitialStateStatement | InjectStatement | SubscribeStatement;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface ContextStatement extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'ContextStatement';
    keyItems: Array<RawKeyItem>;
    reducerItems: Array<KeyItem>;
}

export const ContextStatement = 'ContextStatement';

export function isContextStatement(item: unknown): item is ContextStatement {
    return reflection.isInstance(item, ContextStatement);
}

export interface DefineStatement extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'DefineStatement';
    arguments: Array<string>;
    function: DefineFunction;
    identifier: string;
}

export const DefineStatement = 'DefineStatement';

export function isDefineStatement(item: unknown): item is DefineStatement {
    return reflection.isInstance(item, DefineStatement);
}

export interface EmitStatement extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'EmitStatement';
    contextItems: Array<RawKeyItem>;
    identifier: string;
    metaItems: Array<KeyItem>;
}

export const EmitStatement = 'EmitStatement';

export function isEmitStatement(item: unknown): item is EmitStatement {
    return reflection.isInstance(item, EmitStatement);
}

export interface Expression extends langium.AstNode {
    readonly $type: 'ArgumentReference' | 'ArrayLiteral' | 'Constant' | 'ContextReference' | 'DataObject' | 'DataObjectReference' | 'Expression' | 'FunctionCall' | 'Immutable' | 'NumberLiteral' | 'PayloadReference' | 'StringLiteral';
    inner?: Expression;
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface ExpressionStatement extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'ExpressionStatement';
    expression: Expression;
}

export const ExpressionStatement = 'ExpressionStatement';

export function isExpressionStatement(item: unknown): item is ExpressionStatement {
    return reflection.isInstance(item, ExpressionStatement);
}

export interface InjectStatement extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'InjectStatement';
    identifier: string;
}

export const InjectStatement = 'InjectStatement';

export function isInjectStatement(item: unknown): item is InjectStatement {
    return reflection.isInstance(item, InjectStatement);
}

export interface Model extends langium.AstNode {
    readonly $type: 'Model';
    statements: Array<Statement>;
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface RawKeyItem extends langium.AstNode {
    readonly $container: ContextStatement | EmitStatement;
    readonly $type: 'RawKeyItem';
    expression?: Expression;
    identifier: string;
}

export const RawKeyItem = 'RawKeyItem';

export function isRawKeyItem(item: unknown): item is RawKeyItem {
    return reflection.isInstance(item, RawKeyItem);
}

export interface StatementI extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'ByPassStatement' | 'InitialStateStatement' | 'StatementI';
}

export const StatementI = 'StatementI';

export function isStatementI(item: unknown): item is StatementI {
    return reflection.isInstance(item, StatementI);
}

export interface SubscribeStatement extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'SubscribeStatement';
    actionName: string;
    eventIdentifier: string;
    metaItems: Array<KeyItem>;
    payloadItems: Array<KeyItem>;
}

export const SubscribeStatement = 'SubscribeStatement';

export function isSubscribeStatement(item: unknown): item is SubscribeStatement {
    return reflection.isInstance(item, SubscribeStatement);
}

export interface ArgumentReference extends Expression {
    readonly $container: DefineStatement;
    readonly $type: 'ArgumentReference';
    name: string;
}

export const ArgumentReference = 'ArgumentReference';

export function isArgumentReference(item: unknown): item is ArgumentReference {
    return reflection.isInstance(item, ArgumentReference);
}

export interface DataObject extends Expression {
    readonly $container: ContextStatement | EmitStatement | SubscribeStatement;
    readonly $type: 'DataObject';
    expression?: Expression;
    reference: DataObjectReference;
}

export const DataObject = 'DataObject';

export function isDataObject(item: unknown): item is DataObject {
    return reflection.isInstance(item, DataObject);
}

export interface DataObjectReference extends Expression {
    readonly $type: 'Constant' | 'ContextReference' | 'DataObjectReference' | 'PayloadReference';
}

export const DataObjectReference = 'DataObjectReference';

export function isDataObjectReference(item: unknown): item is DataObjectReference {
    return reflection.isInstance(item, DataObjectReference);
}

export interface FunctionCall extends Expression {
    readonly $container: ContextStatement | DefineStatement | EmitStatement | SubscribeStatement;
    readonly $type: 'FunctionCall';
    arguments: Array<Expression>;
    name: string;
}

export const FunctionCall = 'FunctionCall';

export function isFunctionCall(item: unknown): item is FunctionCall {
    return reflection.isInstance(item, FunctionCall);
}

export interface Immutable extends Expression {
    readonly $type: 'ArrayLiteral' | 'Immutable' | 'NumberLiteral' | 'StringLiteral';
}

export const Immutable = 'Immutable';

export function isImmutable(item: unknown): item is Immutable {
    return reflection.isInstance(item, Immutable);
}

export interface ByPassStatement extends StatementI {
    readonly $container: Model;
    readonly $type: 'ByPassStatement';
    byPass: boolean;
}

export const ByPassStatement = 'ByPassStatement';

export function isByPassStatement(item: unknown): item is ByPassStatement {
    return reflection.isInstance(item, ByPassStatement);
}

export interface InitialStateStatement extends StatementI {
    readonly $container: Model;
    readonly $type: 'InitialStateStatement';
    initialState: boolean;
}

export const InitialStateStatement = 'InitialStateStatement';

export function isInitialStateStatement(item: unknown): item is InitialStateStatement {
    return reflection.isInstance(item, InitialStateStatement);
}

export interface Constant extends DataObjectReference {
    readonly $container: DefineStatement;
    readonly $type: 'Constant';
    identifier: string;
}

export const Constant = 'Constant';

export function isConstant(item: unknown): item is Constant {
    return reflection.isInstance(item, Constant);
}

export interface ContextReference extends DataObjectReference {
    readonly $type: 'ContextReference';
    identifier: string;
}

export const ContextReference = 'ContextReference';

export function isContextReference(item: unknown): item is ContextReference {
    return reflection.isInstance(item, ContextReference);
}

export interface PayloadReference extends DataObjectReference {
    readonly $type: 'PayloadReference';
    identifier: string;
}

export const PayloadReference = 'PayloadReference';

export function isPayloadReference(item: unknown): item is PayloadReference {
    return reflection.isInstance(item, PayloadReference);
}

export interface ArrayLiteral extends Immutable {
    readonly $type: 'ArrayLiteral';
    elements: Array<Expression>;
}

export const ArrayLiteral = 'ArrayLiteral';

export function isArrayLiteral(item: unknown): item is ArrayLiteral {
    return reflection.isInstance(item, ArrayLiteral);
}

export interface NumberLiteral extends Immutable {
    readonly $type: 'NumberLiteral';
    value: number;
}

export const NumberLiteral = 'NumberLiteral';

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral);
}

export interface StringLiteral extends Immutable {
    readonly $type: 'StringLiteral';
    value: string;
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export type YantrixLanguageAstType = {
    ArgumentReference: ArgumentReference
    ArrayLiteral: ArrayLiteral
    ByPassStatement: ByPassStatement
    Constant: Constant
    ContextReference: ContextReference
    ContextStatement: ContextStatement
    DataObject: DataObject
    DataObjectReference: DataObjectReference
    DefineFunction: DefineFunction
    DefineStatement: DefineStatement
    EmitStatement: EmitStatement
    Expression: Expression
    ExpressionStatement: ExpressionStatement
    FunctionCall: FunctionCall
    Immutable: Immutable
    InitialStateStatement: InitialStateStatement
    InjectStatement: InjectStatement
    KeyItem: KeyItem
    Model: Model
    NumberLiteral: NumberLiteral
    PayloadReference: PayloadReference
    RawKeyItem: RawKeyItem
    Statement: Statement
    StatementI: StatementI
    StringLiteral: StringLiteral
    SubscribeStatement: SubscribeStatement
}

export class YantrixLanguageAstReflection extends langium.AbstractAstReflection {

    getAllTypes(): string[] {
        return [ArgumentReference, ArrayLiteral, ByPassStatement, Constant, ContextReference, ContextStatement, DataObject, DataObjectReference, DefineFunction, DefineStatement, EmitStatement, Expression, ExpressionStatement, FunctionCall, Immutable, InitialStateStatement, InjectStatement, KeyItem, Model, NumberLiteral, PayloadReference, RawKeyItem, Statement, StatementI, StringLiteral, SubscribeStatement];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case ArgumentReference: {
                return this.isSubtype(DefineFunction, supertype) || this.isSubtype(Expression, supertype);
            }
            case ArrayLiteral:
            case NumberLiteral:
            case StringLiteral: {
                return this.isSubtype(Immutable, supertype);
            }
            case ByPassStatement:
            case InitialStateStatement: {
                return this.isSubtype(Statement, supertype) || this.isSubtype(StatementI, supertype);
            }
            case Constant: {
                return this.isSubtype(DataObjectReference, supertype) || this.isSubtype(DefineFunction, supertype);
            }
            case ContextReference:
            case PayloadReference: {
                return this.isSubtype(DataObjectReference, supertype);
            }
            case ContextStatement:
            case DefineStatement:
            case EmitStatement:
            case ExpressionStatement:
            case InjectStatement:
            case SubscribeStatement: {
                return this.isSubtype(Statement, supertype);
            }
            case DataObject: {
                return this.isSubtype(Expression, supertype) || this.isSubtype(KeyItem, supertype);
            }
            case DataObjectReference: {
                return this.isSubtype(Expression, supertype);
            }
            case FunctionCall:
            case Immutable: {
                return this.isSubtype(DefineFunction, supertype) || this.isSubtype(Expression, supertype) || this.isSubtype(KeyItem, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): langium.TypeMetaData {
        switch (type) {
            case ContextStatement: {
                return {
                    name: ContextStatement,
                    properties: [
                        { name: 'keyItems', defaultValue: [] },
                        { name: 'reducerItems', defaultValue: [] }
                    ]
                };
            }
            case DefineStatement: {
                return {
                    name: DefineStatement,
                    properties: [
                        { name: 'arguments', defaultValue: [] },
                        { name: 'function' },
                        { name: 'identifier' }
                    ]
                };
            }
            case EmitStatement: {
                return {
                    name: EmitStatement,
                    properties: [
                        { name: 'contextItems', defaultValue: [] },
                        { name: 'identifier' },
                        { name: 'metaItems', defaultValue: [] }
                    ]
                };
            }
            case Expression: {
                return {
                    name: Expression,
                    properties: [
                        { name: 'inner' }
                    ]
                };
            }
            case ExpressionStatement: {
                return {
                    name: ExpressionStatement,
                    properties: [
                        { name: 'expression' }
                    ]
                };
            }
            case InjectStatement: {
                return {
                    name: InjectStatement,
                    properties: [
                        { name: 'identifier' }
                    ]
                };
            }
            case Model: {
                return {
                    name: Model,
                    properties: [
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            case RawKeyItem: {
                return {
                    name: RawKeyItem,
                    properties: [
                        { name: 'expression' },
                        { name: 'identifier' }
                    ]
                };
            }
            case SubscribeStatement: {
                return {
                    name: SubscribeStatement,
                    properties: [
                        { name: 'actionName' },
                        { name: 'eventIdentifier' },
                        { name: 'metaItems', defaultValue: [] },
                        { name: 'payloadItems', defaultValue: [] }
                    ]
                };
            }
            case ArgumentReference: {
                return {
                    name: ArgumentReference,
                    properties: [
                        { name: 'inner' },
                        { name: 'name' }
                    ]
                };
            }
            case DataObject: {
                return {
                    name: DataObject,
                    properties: [
                        { name: 'expression' },
                        { name: 'inner' },
                        { name: 'reference' }
                    ]
                };
            }
            case DataObjectReference: {
                return {
                    name: DataObjectReference,
                    properties: [
                        { name: 'inner' }
                    ]
                };
            }
            case FunctionCall: {
                return {
                    name: FunctionCall,
                    properties: [
                        { name: 'arguments', defaultValue: [] },
                        { name: 'inner' },
                        { name: 'name' }
                    ]
                };
            }
            case Immutable: {
                return {
                    name: Immutable,
                    properties: [
                        { name: 'inner' }
                    ]
                };
            }
            case ByPassStatement: {
                return {
                    name: ByPassStatement,
                    properties: [
                        { name: 'byPass', defaultValue: false }
                    ]
                };
            }
            case InitialStateStatement: {
                return {
                    name: InitialStateStatement,
                    properties: [
                        { name: 'initialState', defaultValue: false }
                    ]
                };
            }
            case Constant: {
                return {
                    name: Constant,
                    properties: [
                        { name: 'identifier' },
                        { name: 'inner' }
                    ]
                };
            }
            case ContextReference: {
                return {
                    name: ContextReference,
                    properties: [
                        { name: 'identifier' },
                        { name: 'inner' }
                    ]
                };
            }
            case PayloadReference: {
                return {
                    name: PayloadReference,
                    properties: [
                        { name: 'identifier' },
                        { name: 'inner' }
                    ]
                };
            }
            case ArrayLiteral: {
                return {
                    name: ArrayLiteral,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'inner' }
                    ]
                };
            }
            case NumberLiteral: {
                return {
                    name: NumberLiteral,
                    properties: [
                        { name: 'inner' },
                        { name: 'value' }
                    ]
                };
            }
            case StringLiteral: {
                return {
                    name: StringLiteral,
                    properties: [
                        { name: 'inner' },
                        { name: 'value' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new YantrixLanguageAstReflection();
